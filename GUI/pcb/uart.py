import crcmod
import serial
import serial.tools.list_ports
import asyncio
import aioserial
import aioconsole

import secrets

def get_ports():
	ports = list(serial.tools.list_ports.comports())
	ports.sort()
	return ports

crc16 = crcmod.mkCrcFun(0x1A2EB)
crc8 = crcmod.mkCrcFun(0x1D7)

length_correction_crc8_table = [
	0xFF, 0xFF, 0x01, 0xFF, 0x02, 0xFF, 0xFF, 0xFF,
	0x04, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x08, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x10, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x20, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x40, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x80,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
]

def crc_test():
	print(f"0x{format(crc16(bytes()), '04X')}")
	print(f"0x{format(crc16(bytes([0])), '04X')}")
	print(f"0x{format(crc8(bytes()), '02X')}")
	print(f"0x{format(crc8(bytes([0xFF])), '02X')}")


# TODO: Translate C code for packet reception to Python

# TODO: FPGA expects configuration data LSB-first, but our SPI bus is running MSB-first.
# When loading configuration files onto the flash memory, flip the order of the bits.

def detect_packet(buffer):
	count = len(buffer) - 2
	for i in range(count):
		error = buffer[i] ^ 0xCA
		error &= error - 1
		if error == 0:
			#Potential sync byte...
			error = crc8(buffer[i+1:i+3])
			if error == 0:
				#Found packet...
				return i
			#CRC invalid, attempt correction...
			error = length_correction_crc8_table[error]
			if error != 0xFF:
				buffer[i+1] ^= error
				return i
	return -1

class PacketStream:
	def __init__(self, port):
		self.tx_lock = asyncio.Lock()
		self.rx_lock = asyncio.Lock()
		if not isinstance(port, str):
			port = port.device
		self.port = aioserial.AioSerial(port, 230400)

	async def write_packet(self, payload, byte_sync_count=1):
		#Build packet
		length = len(payload) - 3
		extra = 0
		if length < 0:
			extra = -length
			length = 0
		packet = bytearray()
		while byte_sync_count > 0:
			packet.append(0xFF)
			byte_sync_count -= 1
		packet.append(0xCA)
		packet.append(length)
		packet.append(crc8(bytes([length])))
		packet.extend(payload)
		#Zero-padding to minimum length (CRC ignores trailing zeros anyway)
		while extra > 0:
			packet.append(0)
		packet.extend(crc16(payload).to_bytes(2, 'little'))
		#Write packet to UART
		print(' '.join('{:02x}'.format(b) for b in packet))
		async with self.tx_lock:
			await self.port.write_async(packet)

	async def read_packet(self):
		async with self.rx_lock:
			buffer = bytes(8)
			#TODO: Loop until header detected
			await self.port.readinto_async(buffer)
			offset = detect_packet(buffer)
			if offset >= 0:
				length = 8 - offset
				#TODO: Receive rest of packet
		return None

async def send_test_packets():
	ports = get_ports()
	for p in ports:
		print(str(p))
	port = PacketStream(input("Port: "))
	i = 0
	while True:
		await port.write_packet(i.to_bytes(4, 'little') + secrets.token_bytes(secrets.randbelow(40)), i % 8)
		i += 1
		await aioconsole.ainput("Send packet?")
		await asyncio.sleep(0.1)

if __name__ == "__main__":
	asyncio.run(send_test_packets())
